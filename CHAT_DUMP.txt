== CITY-PUBLIC CHAT DUMP ==
== UPDATED BY GITHUB ACTIONS ==

== FILE TREE ==
.editorconfig
.gitattributes
.gitignore
icon.svg
project.godot
scenes/Game.tscn
scenes/Overview3D.tscn
scripts/building_manager.gd
scripts/camera_controller.gd
scripts/grid_overlay.gd

== CONTENTS (project.godot + *.gd + *.tscn) ==

----- FILE: project.godot (bytes=919) -----
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="城市建造"
run/main_scene="uid://dljy8a1klbloc"
config/features=PackedStringArray("4.5", "Forward Plus")
config/icon="res://icon.svg"

[display]

window/size/viewport_width=1920
window/size/viewport_height=1080
window/stretch/mode="viewport"
window/stretch/scale_mode="integer"

[input]

cam_pan={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":32,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}

----- FILE: scenes/Game.tscn (bytes=2636) -----
[gd_scene load_steps=5 format=3 uid="uid://dljy8a1klbloc"]

[ext_resource type="Script" uid="uid://ds41cprh62216" path="res://scripts/grid_overlay.gd" id="1_cpr0p"]
[ext_resource type="PackedScene" uid="uid://be0ijmd1n541a" path="res://scenes/Overview3D.tscn" id="1_ibkli"]
[ext_resource type="Script" uid="uid://cf3lkqte5oqc1" path="res://scripts/building_manager.gd" id="2_78awf"]
[ext_resource type="Script" uid="uid://ddgoirhogq27o" path="res://scripts/camera_controller.gd" id="3_78awf"]

[node name="Game" type="Node2D"]

[node name="World2D" type="Node2D" parent="."]

[node name="GridOverlay" type="Node2D" parent="World2D"]
script = ExtResource("1_cpr0p")

[node name="Buildings" type="Node2D" parent="World2D"]

[node name="BuildingManager" type="Node2D" parent="World2D"]
script = ExtResource("2_78awf")

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(480, 288)
zoom = Vector2(5, 5)
script = ExtResource("3_78awf")
invert_trackpad_pan = true

[node name="UI" type="CanvasLayer" parent="."]

[node name="HUD" type="Control" parent="UI"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="RootHBox" type="HBoxContainer" parent="UI/HUD"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2

[node name="LeftFill" type="Control" parent="UI/HUD/RootHBox"]
layout_mode = 2
size_flags_horizontal = 3
mouse_filter = 2

[node name="RightPanel" type="PanelContainer" parent="UI/HUD/RootHBox"]
custom_minimum_size = Vector2(420, 0)
layout_mode = 2

[node name="Margin" type="MarginContainer" parent="UI/HUD/RootHBox/RightPanel"]
layout_mode = 2
theme_override_constants/margin_left = 12
theme_override_constants/margin_top = 12
theme_override_constants/margin_right = 12
theme_override_constants/margin_bottom = 12

[node name="VBox" type="VBoxContainer" parent="UI/HUD/RootHBox/RightPanel/Margin"]
layout_mode = 2

[node name="TitleLabel" type="Label" parent="UI/HUD/RootHBox/RightPanel/Margin/VBox"]
layout_mode = 2
text = "Overview"

[node name="OverviewContainer" type="SubViewportContainer" parent="UI/HUD/RootHBox/RightPanel/Margin/VBox"]
custom_minimum_size = Vector2(400, 400)
layout_mode = 2

[node name="OverviewViewport" type="SubViewport" parent="UI/HUD/RootHBox/RightPanel/Margin/VBox/OverviewContainer"]
handle_input_locally = false
size = Vector2i(400, 400)
render_target_update_mode = 4

[node name="Overview3D" parent="UI/HUD/RootHBox/RightPanel/Margin/VBox/OverviewContainer/OverviewViewport" instance=ExtResource("1_ibkli")]

----- FILE: scenes/Overview3D.tscn (bytes=1142) -----
[gd_scene load_steps=4 format=3 uid="uid://be0ijmd1n541a"]

[sub_resource type="PlaneMesh" id="PlaneMesh_yvvut"]
size = Vector2(30, 18)

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_7v750"]
albedo_color = Color(0.078431375, 0.078431375, 0.078431375, 1)

[sub_resource type="BoxMesh" id="BoxMesh_yvvut"]

[node name="Overview3D" type="Node3D"]

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 0.70710677, 0.70710677, 0, -0.70710677, 0.70710677, 5, 22, 20)
projection = 1
size = 18.0

[node name="Ground" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.009188175, 0, -0.005378723)
mesh = SubResource("PlaneMesh_yvvut")
surface_material_override/0 = SubResource("StandardMaterial3D_7v750")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(0.70710677, -0.61237246, 0.35355335, 0, 0.49999997, 0.86602545, -0.70710677, -0.61237246, 0.35355335, 0, 0, 0)

[node name="TestBox" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 5, 0.5, 5)
mesh = SubResource("BoxMesh_yvvut")

----- FILE: scripts/building_manager.gd (bytes=3542) -----
## ============================================================
## 模块名称: 建筑管理器（BuildingManager）
## 创建日期: 2026-01-11
## 功能说明:
##   - 左键：在网格格子放置占位建筑
##   - 右键：删除格子中的占位建筑
##   - 使用 Dictionary 记录格子占用
## 依赖关系:
##   - 同级节点 `GridOverlay`（挂载 `GridOverlay` 脚本）
##   - 同级节点 `Buildings`（作为建筑占位节点容器）
## ============================================================

extends Node2D

const TILE_SIZE := 32

## 格子占用表：key=Vector2i（格子坐标），value=Node（该格子的占位节点）。
var occupied: Dictionary = {}

## @onready：节点进入场景树后再获取引用，避免还没 ready 时找不到节点。
@onready var _grid_overlay: GridOverlay = get_parent().get_node_or_null("GridOverlay") as GridOverlay
@onready var _buildings: Node2D = get_parent().get_node_or_null("Buildings") as Node2D

func _ready() -> void:
	if _grid_overlay == null:
		push_error("BuildingManager: 未找到同级节点 GridOverlay（期望路径：World2D/GridOverlay）")
		set_process_unhandled_input(false)
		return
	if _buildings == null:
		push_error("BuildingManager: 未找到同级节点 Buildings（期望路径：World2D/Buildings）")
		set_process_unhandled_input(false)
		return

## 鼠标点击交互：
## - 左键：空格子则放置
## - 右键：占用则删除
func _unhandled_input(event: InputEvent) -> void:
	if not (event is InputEventMouseButton):
		return

	var mouse_event := event as InputEventMouseButton
	if not mouse_event.pressed or mouse_event.is_echo():
		return

	# 若正在相机平移（Cmd/Ctrl + 左键），则不处理左键放置，避免拖拽时误放置。
	if (Input.is_key_pressed(KEY_META) or Input.is_key_pressed(KEY_CTRL)) and mouse_event.button_index == MOUSE_BUTTON_LEFT:
		return

	# 步骤1：通过 GridOverlay 统一完成“世界坐标 → 格子坐标”的转换
	var cell: Vector2i = _grid_overlay.world_to_cell(get_global_mouse_position())
	# 步骤2：越界直接忽略（防止在网格外误放置）
	if cell.x < 0 or cell.x >= _grid_overlay.GRID_W or cell.y < 0 or cell.y >= _grid_overlay.GRID_H:
		return

	if mouse_event.button_index == MOUSE_BUTTON_LEFT:
		# 步骤3：检查是否已占用
		if occupied.has(cell):
			return

		# 步骤4：创建占位块（ColorRect：简单可见的方块）
		var placeholder := ColorRect.new()
		placeholder.color = Color(0.55, 0.55, 0.55, 1.0)
		placeholder.size = Vector2(TILE_SIZE, TILE_SIZE)
		# 让占位块不拦截鼠标事件，避免影响后续点击检测
		placeholder.mouse_filter = Control.MOUSE_FILTER_IGNORE

		# 步骤5：对齐到格子左上角（以 GridOverlay 的坐标系为准）
		var world_pos: Vector2 = _grid_overlay.cell_to_world(cell)
		placeholder.position = _buildings.to_local(world_pos)
		_buildings.add_child(placeholder)

		# 步骤6：记录占用并输出日志
		occupied[cell] = placeholder
		print("Placed at (%d,%d)" % [cell.x, cell.y])
		return

	if mouse_event.button_index == MOUSE_BUTTON_RIGHT:
		# 步骤3：检查是否有占用可删
		if not occupied.has(cell):
			return

		# Dictionary 取值可能没有静态类型：这里显式声明为 Node，避免解析期类型推断报错。
		var node: Node = occupied.get(cell) as Node
		if node != null and is_instance_valid(node):
			node.queue_free()
		# 步骤4：移除占用记录并输出日志
		occupied.erase(cell)
		print("Removed at (%d,%d)" % [cell.x, cell.y])

----- FILE: scripts/camera_controller.gd (bytes=5524) -----
## ============================================================
## 模块名称: 相机控制器（CameraController）
## 创建日期: 2026-01-11
## 功能说明:
##   - 鼠标滚轮：缩放
##   - 触控板两指拖动：平移画布（Cmd/Ctrl + 两指拖动=缩放）
##   - 触控板捏合：缩放
##   - Cmd/Ctrl + 鼠标左键拖拽：平移画布
##   - Space：重置缩放到初始值
## 依赖关系:
##   - 挂载到 `Camera2D` 节点
##   - `project.godot` 中存在输入动作 `cam_pan`（已绑定 Space）
## ============================================================

extends Camera2D

## 最小缩放（越小越远）。
@export var zoom_min: float = 2.0
## 最大缩放（越大越近）。
@export var zoom_max: float = 8.0

## 鼠标滚轮每格缩放倍率（越大越快）。
@export var wheel_zoom_step: float = 1.5

## Cmd/Ctrl + 鼠标拖拽平移速度系数（越大越快）。
@export var mouse_pan_speed: float = 3.0
## 鼠标拖拽平移的平滑程度（0=无平滑，0.1~0.3较顺滑）。
@export var mouse_pan_smoothness: float = 0.25

## 触控板两指拖动平移速度系数（越大越快）。
@export var trackpad_pan_speed: float = 7.0
## 触控板两指拖动方向反转（符合个人直觉则勾选）。
@export var invert_trackpad_pan: bool = false

@export var trackpad_zoom_step: float = 1.12
@export var trackpad_zoom_sensitivity: float = 0.02
@export var trackpad_delta_clamp: float = 80.0

var _panning := false
var _last_mouse_pos: Vector2 = Vector2.ZERO
var _trackpad_pan_accum: Vector2 = Vector2.ZERO
var _saw_wheel_this_frame := false
var _default_zoom: Vector2 = Vector2.ONE
var _reset_tween: Tween = null

func _ready() -> void:
	# 初始 zoom = Vector2(5,5)（场景里已设置；这里兜底一次）
	zoom = Vector2(5, 5)
	_set_zoom_scalar(zoom.x)
	set_process(true)
	_default_zoom = zoom

func _unhandled_input(event: InputEvent) -> void:
	# 1) 鼠标按键 + 滚轮缩放
	if event is InputEventMouseButton:
		var mouse_button := event as InputEventMouseButton
		if mouse_button.is_echo():
			return

		# 左键：Cmd/Ctrl 按住时进入/退出鼠标拖拽平移
		if mouse_button.button_index == MOUSE_BUTTON_LEFT:
			if mouse_button.pressed and (Input.is_key_pressed(KEY_META) or Input.is_key_pressed(KEY_CTRL)):
				_panning = true
				_last_mouse_pos = get_viewport().get_mouse_position()
				return
			if not mouse_button.pressed:
				_panning = false
				return

		# 鼠标滚轮缩放：每格 ×step 或 ÷step，clamp 在 [zoom_min, zoom_max]
		if mouse_button.pressed:
			if mouse_button.button_index == MOUSE_BUTTON_WHEEL_UP:
				_saw_wheel_this_frame = true
				_set_zoom_scalar(zoom.x * wheel_zoom_step)
				return
			if mouse_button.button_index == MOUSE_BUTTON_WHEEL_DOWN:
				_saw_wheel_this_frame = true
				_set_zoom_scalar(zoom.x / wheel_zoom_step)
				return

	# 2) 触控板两指拖动：PanGesture（平移）
	if event is InputEventPanGesture:
		# 若同一帧检测到鼠标滚轮事件，则忽略 PanGesture，避免滚轮触发平移。
		if _saw_wheel_this_frame:
			return
		var pan := event as InputEventPanGesture
		# Cmd/Ctrl + 两指拖动：缩放
		if Input.is_key_pressed(KEY_META) or Input.is_key_pressed(KEY_CTRL):
			var dy := clampf(pan.delta.y, -trackpad_delta_clamp, trackpad_delta_clamp)
			var factor := pow(trackpad_zoom_step, -dy * trackpad_zoom_sensitivity)
			_set_zoom_scalar(zoom.x * factor)
		else:
			_trackpad_pan_accum += pan.delta
		return

	# 3) 触控板捏合：MagnifyGesture（factor 接近 1.0，>1 通常放大，<1 缩小）
	if event is InputEventMagnifyGesture:
		var magnify := event as InputEventMagnifyGesture
		_set_zoom_scalar(zoom.x * magnify.factor)
		return

	# 4) Space：重置缩放到初始值
	if event is InputEventKey:
		var key_event := event as InputEventKey
		if key_event.pressed and key_event.keycode == KEY_SPACE:
			# 0.5 秒回到初始缩放，避免“瞬间跳变”的生硬感
			if _reset_tween != null and _reset_tween.is_running():
				_reset_tween.kill()
			_reset_tween = create_tween()
			_reset_tween.tween_property(self, "zoom", _default_zoom, 0.5).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)
			return

	# 鼠标拖拽平移在 _process 里按帧计算（更稳定，减少“掉帧感”）

func _process(_delta: float) -> void:
	# 每帧重置滚轮标记（用于避免滚轮触发 PanGesture 平移）
	_saw_wheel_this_frame = false

	# 1) 触控板两指拖动平移
	if _trackpad_pan_accum != Vector2.ZERO:
		var z_trackpad := maxf(zoom.x, 0.0001)
		var delta_pan := (_trackpad_pan_accum / z_trackpad) * trackpad_pan_speed
		if invert_trackpad_pan:
			position += delta_pan
		else:
			position -= delta_pan
		_trackpad_pan_accum = Vector2.ZERO

	# 2) Space + 左键拖拽平移（鼠标）
	if not _panning:
		return
	if not (Input.is_key_pressed(KEY_META) or Input.is_key_pressed(KEY_CTRL)) or not Input.is_mouse_button_pressed(MOUSE_BUTTON_LEFT):
		_panning = false
		return

	var current_mouse_pos := get_viewport().get_mouse_position()
	var delta_screen := current_mouse_pos - _last_mouse_pos
	_last_mouse_pos = current_mouse_pos
	if delta_screen == Vector2.ZERO:
		return

	var z_mouse := maxf(zoom.x, 0.0001)
	var target_pos := position - (delta_screen / z_mouse) * mouse_pan_speed
	if mouse_pan_smoothness <= 0.0:
		position = target_pos
	else:
		position = position.lerp(target_pos, clampf(mouse_pan_smoothness, 0.0, 1.0))

func _set_zoom_scalar(z: float) -> void:
	z = clampf(z, zoom_min, zoom_max)
	zoom = Vector2(z, z)

----- FILE: scripts/grid_overlay.gd (bytes=3225) -----
## ============================================================
## 模块名称: 网格覆盖层（GridOverlay）
## 创建日期: 2026-01-11
## 功能说明:
##   - 绘制 32×32 的网格线与外框
##   - 提供 world↔cell 坐标转换
##   - 可选：鼠标悬停格子高亮
## 依赖关系:
##   - 挂载到 `World2D/GridOverlay`（Node2D）
## ============================================================

class_name GridOverlay
extends Node2D

## 单个格子的边长（像素）。
const TILE_SIZE := 32
## 网格宽度（格子数）。
const GRID_W := 30
## 网格高度（格子数）。
const GRID_H := 18

## 当前鼠标悬停的格子坐标；(-1,-1) 表示无效/未命中。
var _hover_cell: Vector2i = Vector2i(-1, -1)

## 初始化：进入场景树后立刻绘制一次。
func _ready() -> void:
	queue_redraw()

## 处理鼠标移动：更新悬停格子并触发重绘（用于高亮效果）。
func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventMouseMotion:
		# 平移相机时不更新悬停高亮，避免额外重绘造成“卡顿感”
		if (Input.is_key_pressed(KEY_META) or Input.is_key_pressed(KEY_CTRL)) and Input.is_mouse_button_pressed(MOUSE_BUTTON_LEFT):
			return
		# 步骤1：将鼠标世界坐标转换为格子坐标
		var cell := world_to_cell(get_global_mouse_position())
		if cell != _hover_cell:
			# 步骤2：只有变化时才重绘，减少无意义的 redraw
			_hover_cell = cell
			queue_redraw()

## 绘制回调：画淡色网格线、外框，并可选画鼠标悬停高亮。
func _draw() -> void:
	# 步骤1：计算整个网格的像素尺寸
	var grid_pixel_w := GRID_W * TILE_SIZE
	var grid_pixel_h := GRID_H * TILE_SIZE

	var line_color := Color(1, 1, 1, 0.18)
	var border_color := Color(1, 1, 1, 0.35)

	# 步骤2（可选）：鼠标悬停高亮（半透明填充）
	if _hover_cell.x >= 0 and _hover_cell.x < GRID_W and _hover_cell.y >= 0 and _hover_cell.y < GRID_H:
		draw_rect(
			Rect2(Vector2(_hover_cell) * TILE_SIZE, Vector2(TILE_SIZE, TILE_SIZE)),
			Color(1, 1, 1, 0.12),
			true
		)

	# 步骤3：画网格线（竖线 + 横线）
	for x in range(GRID_W + 1):
		var px := x * TILE_SIZE
		draw_line(Vector2(px, 0), Vector2(px, grid_pixel_h), line_color, 1.0)
	for y in range(GRID_H + 1):
		var py := y * TILE_SIZE
		draw_line(Vector2(0, py), Vector2(grid_pixel_w, py), line_color, 1.0)

	# 步骤4：画外框（矩形描边）
	draw_rect(Rect2(Vector2.ZERO, Vector2(grid_pixel_w, grid_pixel_h)), border_color, false, 2.0)

## 世界坐标 → 格子坐标（向下取整）。
## @param world_pos: 世界坐标（global）
## @return: 格子坐标（Vector2i）
func world_to_cell(world_pos: Vector2) -> Vector2i:
	# Node2D.to_local：把世界坐标转换为本节点的局部坐标
	var local_pos := to_local(world_pos)
	return Vector2i(floori(local_pos.x / TILE_SIZE), floori(local_pos.y / TILE_SIZE))

## 格子坐标 → 世界坐标（格子的左上角）。
## @param cell: 格子坐标（Vector2i）
## @return: 左上角对应的世界坐标（Vector2）
func cell_to_world(cell: Vector2i) -> Vector2:
	# Node2D.to_global：把本节点局部坐标转换为世界坐标
	return to_global(Vector2(cell) * TILE_SIZE)
